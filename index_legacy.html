<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zoo Bumpers: Tuƒç≈à√°ci vs Opice</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Titan+One&display=swap');

        body {
            font-family: 'Titan One', cursive;
            background-color: #1e3a8a;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #63b3ed 0%, #2c5282 100%);
        }

        canvas {
            box-shadow: 0 30px 60px rgba(0,0,0,0.6);
        }

        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            z-index: 5;
        }

        .panel {
            background: linear-gradient(180deg, #fff 0%, #e2e8f0 100%);
            padding: 8px 20px;
            border-radius: 15px;
            border: 4px solid #2d3748;
            box-shadow: 0 6px 0 #1a202c, 0 10px 10px rgba(0,0,0,0.3);
            text-align: center;
            pointer-events: auto;
            color: #2d3748;
            text-shadow: none;
        }

        .turn-indicator {
            font-size: 1.2rem;
            background: #fff;
            border: 4px solid #333;
            box-shadow: 0 5px 0 #000;
            min-width: 220px;
        }

        .p1-turn { border-color: #3182ce; color: #2b6cb0; background: #ebf8ff; } /* Mod≈ô√≠ Tuƒç≈à√°ci */
        .p2-turn { border-color: #d69e2e; color: #d69e2e; background: #fffff0; } /* ≈Ωlut√© Opice */

        #main-menu, #game-over {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
        }

        .title-text {
            font-size: 4rem;
            color: #63b3ed;
            text-shadow: 4px 4px 0 #2c5282, 8px 8px 0 #000;
            margin-bottom: 1rem;
            text-align: center;
            line-height: 1;
        }

        .btn {
            margin-top: 20px;
            padding: 20px 50px;
            font-size: 1.5rem;
            background: linear-gradient(to bottom, #48bb78, #2f855a);
            color: white;
            border: 4px solid #1c4532;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            box-shadow: 0 8px 0 #1c4532, 0 15px 20px rgba(0,0,0,0.4);
            transition: transform 0.1s, box-shadow 0.1s;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(8px);
            box-shadow: 0 0 0 #1c4532;
        }

        .hidden { display: none !important; }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        .floating { animation: float 3s ease-in-out infinite; }

        /* Mobile Tweaks */
        @media (max-width: 600px) {
            .title-text { font-size: 2.5rem; }
            .btn { padding: 15px 30px; font-size: 1.2rem; }
            .panel { padding: 5px 10px; font-size: 0.9rem; }
            #score-p1, #score-p2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" class="ui-layer hidden">
        <div class="flex justify-between w-full max-w-4xl mx-auto items-start">
            <div class="panel">
                <div class="text-xs uppercase tracking-wider mb-1">Tuƒç≈à√°ci</div>
                <div id="score-p1" class="text-3xl font-bold text-blue-600">6</div>
            </div>
            
            <div id="turn-display" class="panel turn-indicator">
                Tah Tuƒç≈à√°k≈Ø
            </div>

            <div class="panel">
                <div class="text-xs uppercase tracking-wider mb-1">Opice</div>
                <div id="score-p2" class="text-3xl font-bold text-yellow-600">6</div>
            </div>
        </div>
        
        <!-- Bottom hint -->
        <div class="text-center mb-4 pointer-events-none">
            <span class="bg-black bg-opacity-40 text-white px-4 py-2 rounded-full text-sm font-sans border-2 border-white/20">
                Nat√°hni dozadu a pal! üé±
            </span>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="main-menu">
        <div class="floating">
            <h1 class="title-text">ZOO<br>BUMPERS</h1>
        </div>
        <p class="text-blue-200 text-lg mb-8 font-sans">Tuƒç≈à√°ci üêß vs Opice üêµ</p>
        <button class="btn" onclick="initAudio(); startGame()">HR√ÅT S KAMAR√ÅDEM</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over" class="hidden">
        <h1 id="winner-text" class="title-text text-yellow-400">TUƒå≈á√ÅCI VYHR√ÅLI!</h1>
        <button class="btn" onclick="startGame()">ODVETA</button>
    </div>
</div>

<script>
/**
 * AUDIO SYSTEM (Hybrid: Synth + External Files)
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let soundEnabled = false;

// Stable sounds from Google Actions Library & Wikimedia
const SOUND_URLS = {
    splash: "https://actions.google.com/sounds/v1/water/splash_medium.ogg",
    monkey: "https://actions.google.com/sounds/v1/animals/monkey_screech.ogg",
    funny_fail: "https://actions.google.com/sounds/v1/cartoon/slide_whistle.ogg", 
    win: "https://actions.google.com/sounds/v1/cartoon/clown_horn.ogg",
    pop: "https://actions.google.com/sounds/v1/cartoon/pop_cork.ogg"
};

const loadedSounds = {};

function loadSound(key, url) {
    fetch(url)
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioCtx.decodeAudioData(arrayBuffer))
        .then(audioBuffer => {
            loadedSounds[key] = audioBuffer;
        })
        .catch(e => console.log("Error loading sound:", key, e));
}

function initAudio() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    soundEnabled = true;
    
    // Preload sounds
    Object.keys(SOUND_URLS).forEach(key => {
        loadSound(key, SOUND_URLS[key]);
    });
}

function playExternalSound(key, volume = 0.5) {
    if (!soundEnabled || !loadedSounds[key]) return false;
    
    const source = audioCtx.createBufferSource();
    source.buffer = loadedSounds[key];
    const gain = audioCtx.createGain();
    gain.gain.value = volume;
    source.connect(gain);
    gain.connect(audioCtx.destination);
    source.start(0);
    return true;
}

function playSound(type, extraData) {
    if (!soundEnabled) return;
    const now = audioCtx.currentTime;
    const masterGain = audioCtx.createGain();
    masterGain.connect(audioCtx.destination);

    if (type === 'hit') {
        // Try external pop for hard hits, else synth
        if (Math.random() > 0.5) playExternalSound('pop', 0.6);
        
        // Synth overlay for "clack" feel
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(masterGain);
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
        
    } else if (type === 'wall') {
        // Synth Bonk (reliable)
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(masterGain);
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);

    } else if (type === 'splash') {
        // 1. Water Sound
        playExternalSound('splash', 0.8);

        // 2. Mockery Sound (The other team laughs)
        // extraData is the player who DIED
        setTimeout(() => {
            if (extraData === 1) { 
                // Tuƒç≈à√°k died -> Monkey laughs
                playExternalSound('monkey', 0.6);
            } else {
                // Opice died -> Slide whistle (Tuƒç≈à√°k mockery)
                playExternalSound('funny_fail', 0.7);
            }
        }, 200); // Slight delay for comedic timing

    } else if (type === 'win') {
        playExternalSound('win', 0.8);
    }
}

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Fyzik√°ln√≠ konstanty - upraveno pro lep≈°√≠ pocit
const FRICTION = 0.985; // M√©nƒõ t≈ôen√≠, v√≠ce klouz√°n√≠ (bylo 0.97)
const WALL_BOUNCE = 0.7;
const BALL_BOUNCE = 0.85; // V√≠ce pru≈ænosti
const MAX_POWER = 25;
const MIN_VELOCITY = 0.05;

// Colors
const COLORS = {
    waterDark: '#2b6cb0',
    waterLight: '#4299e1',
    islandTop: '#c3ddfd', // Ledov√° kra pro tuƒç≈à√°ky
    islandSide: '#90cdf4',
    stone: '#4a5568',
    stoneDark: '#2d3748',
};

let gameState = 'MENU'; 
let turn = 1; 
let balls = [];
let walls = [];
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let dragCurrent = { x: 0, y: 0 };
let selectedBall = null;
let bounds = { width: 0, height: 0, cx: 0, cy: 0, rx: 0, ry: 0 };
let waterOffset = 0;

class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    norm() { let m = this.mag(); return m === 0 ? new Vector(0,0) : this.mult(1/m); }
    dist(v) { return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2)); }
    dot(v) { return this.x * v.x + this.y * v.y; }
}

class Wall {
    constructor(x, y, w, h, type) {
        this.pos = new Vector(x, y);
        this.w = w;
        this.h = h;
        this.type = type; 
    }
    
    draw() {
        ctx.fillStyle = COLORS.stone;
        ctx.strokeStyle = COLORS.stoneDark;
        ctx.lineWidth = 3;
        
        ctx.beginPath();
        ctx.roundRect(this.pos.x - this.w/2, this.pos.y - this.h/2, this.w, this.h, 8);
        ctx.fill();
        ctx.stroke();
        
        // Detail kamene
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.beginPath();
        ctx.arc(this.pos.x - this.w/4, this.pos.y - this.h/4, 4, 0, Math.PI*2);
        ctx.fill();
    }

    checkCollision(ball) {
        // Jednoduch√° AABB vs Circle kolize s vy≈ôe≈°en√≠m pozice
        let testX = ball.pos.x;
        let testY = ball.pos.y;
        
        let rx = this.pos.x - this.w/2;
        let ry = this.pos.y - this.h/2;
        
        if (ball.pos.x < rx) testX = rx;
        else if (ball.pos.x > rx + this.w) testX = rx + this.w;
        
        if (ball.pos.y < ry) testY = ry;
        else if (ball.pos.y > ry + this.h) testY = ry + this.h;
        
        let distX = ball.pos.x - testX;
        let distY = ball.pos.y - testY;
        let distance = Math.sqrt((distX*distX) + (distY*distY));
        
        if (distance <= ball.r) {
            // Push out
            let overlap = ball.r - distance;
            // Normalize vector
            let nx = distX / distance;
            let ny = distY / distance;
            
            // Fix NaN for perfect center hit
            if (distance === 0) { nx = 1; ny = 0; }

            ball.pos.x += nx * overlap;
            ball.pos.y += ny * overlap;

            // Reflect Velocity
            let n = new Vector(nx, ny);
            
            // Zjednodu≈°en√° norm√°la pro kv√°dr (aby se neodr√°≈æely divnƒõ od roh≈Ø)
            if (Math.abs(distX) > Math.abs(distY)) {
                n = new Vector(Math.sign(distX), 0);
            } else {
                n = new Vector(0, Math.sign(distY));
            }
            
            let vDotN = ball.vel.dot(n);
            // Odraz se stane jen pokud jde m√≠ƒçek PROTI zdi
            if (vDotN < 0) {
                ball.vel = ball.vel.sub(n.mult(2 * vDotN)).mult(WALL_BOUNCE);
                playSound('wall');
            }
            return true;
        }
        return false;
    }
}

class Ball {
    constructor(id, player, x, y, r) {
        this.id = id;
        this.player = player; 
        this.pos = new Vector(x, y);
        this.vel = new Vector(0, 0);
        this.r = r;
        this.mass = r; 
        this.isDead = false;
        this.scale = 1; 
        this.rotation = 0;
        // N√°hodn√Ω offset pro "wiggle" animaci p≈ôi ƒçek√°n√≠
        this.animOffset = Math.random() * 100;
    }

    update() {
        if (this.isDead) {
            if (this.scale > 0) this.scale -= 0.1;
            return;
        }

        // Physics
        this.pos = this.pos.add(this.vel);
        this.vel = this.vel.mult(FRICTION);
        
        // Rotace podle pohybu (vizu√°ln√≠ efekt)
        this.rotation += this.vel.x * 0.1;

        if (this.vel.mag() < MIN_VELOCITY) this.vel = new Vector(0, 0);

        // Check Walls
        walls.forEach(w => w.checkCollision(this));

        // Check Island Boundary (Fall off)
        let left = bounds.cx - bounds.rx;
        let right = bounds.cx + bounds.rx;
        let top = bounds.cy - bounds.ry;
        let bottom = bounds.cy + bounds.ry;

        if (this.pos.x < left - this.r || this.pos.x > right + this.r || 
            this.pos.y < top - this.r || this.pos.y > bottom + this.r) {
            this.die();
        }
    }

    die() {
        if (this.isDead) return;
        this.isDead = true;
        // Pass this.player so we know who died
        playSound('splash', this.player); 
        checkWinCondition();
    }

    draw() {
        if (this.scale <= 0) return;

        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.scale(this.scale, this.scale);
        ctx.rotate(this.rotation * 0.15); // Jemn√° rotace

        // Z√°kladn√≠ st√≠n
        ctx.beginPath();
        ctx.arc(0, 0, this.r, 0, Math.PI * 2);
        ctx.fillStyle = this.player === 1 ? '#2c3e50' : '#d69e2e'; // Tmav√° pro tuƒç≈à√°ka, ≈Ωlut√° pro opici
        if (this.player === 1) ctx.fillStyle = '#1a202c'; // ƒåern√Ω tuƒç≈à√°k
        ctx.fill();

        // Border
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 2;
        ctx.stroke();

        if (this.player === 1) {
            // --- TUƒå≈á√ÅK üêß ---
            // B√≠l√© b≈ôicho
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(0, 3, this.r * 0.7, this.r * 0.6, 0, 0, Math.PI*2);
            ctx.fill();
            
            // Oƒçi
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(-5, -6, 3, 0, Math.PI*2); ctx.fill(); // Lev√©
            ctx.beginPath(); ctx.arc(5, -6, 3, 0, Math.PI*2); ctx.fill();  // Prav√©
            
            // Odlesk v oƒç√≠ch (cute factor)
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(-6, -7, 1, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(4, -7, 1, 0, Math.PI*2); ctx.fill();

            // Zob√°k
            ctx.fillStyle = '#ed8936';
            ctx.beginPath();
            ctx.moveTo(-4, 0);
            ctx.lineTo(4, 0);
            ctx.lineTo(0, 6);
            ctx.fill();
            
            // Nohy (oran≈æov√©)
            ctx.fillStyle = '#ed8936';
            ctx.beginPath(); ctx.ellipse(-6, 10, 4, 2, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(6, 10, 4, 2, 0, 0, Math.PI*2); ctx.fill();

        } else {
            // --- OPICE üêµ ---
            // Obliƒçej (b√©≈æov√°)
            ctx.fillStyle = '#fefcbf'; 
            ctx.beginPath();
            // Srdcovit√Ω tvar obliƒçeje
            ctx.arc(-5, -2, 7, 0, Math.PI*2);
            ctx.arc(5, -2, 7, 0, Math.PI*2);
            ctx.ellipse(0, 3, 10, 8, 0, 0, Math.PI*2);
            ctx.fill();

            // U≈°i
            ctx.fillStyle = '#d69e2e';
            ctx.beginPath(); ctx.arc(-13, 0, 4, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fefcbf';
            ctx.beginPath(); ctx.arc(-13, 0, 2, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = '#d69e2e';
            ctx.beginPath(); ctx.arc(13, 0, 4, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fefcbf';
            ctx.beginPath(); ctx.arc(13, 0, 2, 0, Math.PI*2); ctx.fill();

            // Oƒçi
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(-5, -1, 2.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(5, -1, 2.5, 0, Math.PI*2); ctx.fill();

            // Pusa
            ctx.beginPath();
            ctx.arc(0, 5, 4, 0, Math.PI, false);
            ctx.strokeStyle = '#744210';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        // Highlight p≈ôi v√Ωbƒõru
        if (selectedBall === this) {
            ctx.beginPath();
            ctx.arc(0, 0, this.r + 6, 0, Math.PI * 2);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        ctx.restore();
    }
}

/**
 * HLAVN√ç LOGIKA
 */
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    let padding = 50;
    let maxWidth = 800;
    let width = Math.min(canvas.width - padding, maxWidth);
    let height = Math.min(canvas.height - padding, width * 0.7); 
    
    bounds = {
        width: width,
        height: height,
        cx: canvas.width / 2,
        cy: canvas.height / 2,
        rx: width / 2,
        ry: height / 2
    };

    createWalls();
}
window.addEventListener('resize', resize);

function createWalls() {
    walls = [];
    const cx = bounds.cx;
    const cy = bounds.cy;
    const rx = bounds.rx;
    const ry = bounds.ry;
    
    const wallThick = 35;
    // O nƒõco krat≈°√≠ zdi, aby byly rohy v√≠c otev≈ôen√© (nebezpeƒçnƒõj≈°√≠)
    const wallLen = rx * 1.1; 

    walls.push(new Wall(cx - rx, cy, wallThick, wallLen, 'vertical'));
    walls.push(new Wall(cx + rx, cy, wallThick, wallLen, 'vertical'));
    walls.push(new Wall(cx, cy - ry, wallLen * 0.6, wallThick, 'horizontal'));
    walls.push(new Wall(cx, cy + ry, wallLen * 0.6, wallThick, 'horizontal'));
}

function initGame() {
    resize();
    balls = [];
    const r = bounds.width * 0.035; 
    
    const count = 12;
    const circleR = bounds.ry * 0.55;
    
    for (let i = 0; i < count; i++) {
        let angle = (Math.PI * 2 * i) / count;
        let x = bounds.cx + Math.cos(angle) * circleR;
        let y = bounds.cy + Math.sin(angle) * circleR;
        
        let p = (i % 2 === 0) ? 1 : 2;
        balls.push(new Ball(i, p, x, y, r));
    }
    
    balls.push(new Ball(99, 1, bounds.cx - r*1.5, bounds.cy, r)); 
    balls.push(new Ball(100, 2, bounds.cx + r*1.5, bounds.cy, r));

    turn = 1;
    updateUI();
}

function startGame() {
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('game-over').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    gameState = 'PLAY';
    initGame();
    animate();
}

function checkCollisions() {
    // 1. F√°ze: Separace (Static resolution) - aby se nelepily
    // Projdeme p√°ry v√≠cekr√°t pro stabilitu (micro-steps)
    for (let k=0; k<2; k++) {
        for (let i = 0; i < balls.length; i++) {
            for (let j = i + 1; j < balls.length; j++) {
                let b1 = balls[i];
                let b2 = balls[j];
                if (b1.isDead || b2.isDead) continue;

                let distV = b1.pos.sub(b2.pos);
                let dist = distV.mag();
                let minDist = b1.r + b2.r;

                if (dist < minDist) {
                    // Vypoƒç√≠tat kolik se p≈ôekr√Ωvaj√≠
                    let overlap = (minDist - dist);
                    // Norm√°la smƒõru
                    let n = distV.norm();
                    
                    // Posunout je od sebe (Static resolution)
                    // Ka≈æd√Ω o polovinu overlapu
                    let correction = n.mult(overlap * 0.51); // 0.51 pro jistotu (nepatrn√° mezera)
                    
                    b1.pos = b1.pos.add(correction);
                    b2.pos = b2.pos.sub(correction);
                }
            }
        }
    }

    // 2. F√°ze: Dynamic resolution (Impulsy)
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            let b1 = balls[i];
            let b2 = balls[j];
            if (b1.isDead || b2.isDead) continue;
            
            let dist = b1.pos.dist(b2.pos);
            let minDist = b1.r + b2.r + 1; // +1 margin

            if (dist <= minDist) {
                let n = b1.pos.sub(b2.pos).norm();
                
                // Relativn√≠ rychlost
                let vRel = b1.vel.sub(b2.vel);
                // Rychlost pod√©l norm√°ly
                let speed = vRel.dot(n);

                // Pokud se od sebe u≈æ vzdaluj√≠, ne≈ôe≈°√≠me
                if (speed > 0) continue;

                // Impuls (pru≈æn√Ω odraz)
                // j = -(1 + e) * velAlongNormal / (1/m1 + 1/m2)
                // Pro stejn√© hmotnosti: j = -(1+e)*speed / 2
                let impulseScalar = -(1 + BALL_BOUNCE) * speed / 2;
                
                let impulse = n.mult(impulseScalar);
                
                b1.vel = b1.vel.add(impulse);
                b2.vel = b2.vel.sub(impulse);
                
                // Zvuk jen p≈ôi silnƒõj≈°√≠m n√°razu
                if (Math.abs(speed) > 0.5) playSound('hit');
            }
        }
    }
}

function update() {
    balls.forEach(b => b.update());
    checkCollisions();

    const moving = balls.some(b => !b.isDead && b.vel.mag() > 0);
    
    if (moving) {
        canvas.style.cursor = 'wait';
    } else {
        if (gameState === 'PLAY') canvas.style.cursor = 'default';
        if (window.wasMoving && !moving) endTurn();
    }
    window.wasMoving = moving;
    
    waterOffset += 0.5;
}

function endTurn() {
    turn = turn === 1 ? 2 : 1;
    updateUI();
}

function updateUI() {
    const p1Count = balls.filter(b => b.player === 1 && !b.isDead).length;
    const p2Count = balls.filter(b => b.player === 2 && !b.isDead).length;

    document.getElementById('score-p1').innerText = p1Count;
    document.getElementById('score-p2').innerText = p2Count;

    const ti = document.getElementById('turn-display');
    if (turn === 1) {
        ti.innerText = "TAH TUƒå≈á√ÅK≈Æ";
        ti.className = "panel turn-indicator p1-turn";
    } else {
        ti.innerText = "TAH OPIC";
        ti.className = "panel turn-indicator p2-turn";
    }
}

function checkWinCondition() {
    const p1Count = balls.filter(b => b.player === 1 && !b.isDead).length;
    const p2Count = balls.filter(b => b.player === 2 && !b.isDead).length;

    if (p1Count === 0 || p2Count === 0) {
        gameState = 'OVER';
        playSound('win');
        const winner = p1Count > 0 ? "TUƒå≈á√ÅCI VYHR√ÅLI!" : "OPICE VYHR√ÅLY!";
        const color = p1Count > 0 ? "text-blue-500" : "text-yellow-500";
        
        const wt = document.getElementById('winner-text');
        wt.innerText = winner;
        wt.className = `title-text ${color}`;
        
        setTimeout(() => {
            document.getElementById('game-over').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
        }, 2500);
    }
}

// --- VYKRESLOV√ÅN√ç ---

function drawIsland() {
    // Voda
    ctx.fillStyle = COLORS.waterDark;
    ctx.fillRect(0,0, canvas.width, canvas.height);
    
    // Vlnky
    ctx.strokeStyle = COLORS.waterLight;
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let y = 0; y < canvas.height; y += 50) {
        let shift = Math.sin((y + waterOffset) * 0.04) * 25;
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y + shift);
    }
    ctx.stroke();

    const cx = bounds.cx;
    const cy = bounds.cy;
    const rx = bounds.rx;
    const ry = bounds.ry;

    // St√≠n ostrova
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.roundRect(cx - rx, cy - ry + 20, rx*2, ry*2, 40);
    ctx.fill();

    // Ostrov (Boky - ledovƒõ modr√©)
    ctx.fillStyle = COLORS.islandSide;
    ctx.beginPath();
    ctx.roundRect(cx - rx, cy - ry, rx*2, ry*2, 40);
    ctx.fill();
    
    // Ostrov (Vr≈°ek - b√≠lo-modr√Ω led)
    ctx.fillStyle = COLORS.islandTop;
    ctx.beginPath();
    ctx.roundRect(cx - rx + 10, cy - ry + 10, rx*2 - 20, ry*2 - 20, 30);
    ctx.fill();

    // Logo na zemi
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = 'bold 40px "Titan One"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText("ZOO", cx, cy - 20);
    ctx.fillText("BUMPERS", cx, cy + 25);
    
    walls.forEach(w => w.draw());
}

function drawAim() {
    if (!isDragging || !selectedBall) return;

    const start = selectedBall.pos;
    let aimVector = start.sub(dragCurrent);
    const mag = aimVector.mag();
    
    let drawEnd = dragCurrent;
    if (mag > 200) {
        drawEnd = start.sub(aimVector.norm().mult(200));
    }

    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(drawEnd.x, drawEnd.y);
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 4;
    ctx.setLineDash([10, 10]);
    ctx.stroke();
    ctx.setLineDash([]);

    const powerRatio = Math.min(mag, 200) / 200;
    const shootDir = aimVector.norm();
    const arrowLen = 60 + (powerRatio * 150);
    const arrowEnd = start.add(shootDir.mult(arrowLen));
    
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(arrowEnd.x, arrowEnd.y);
    
    const r = Math.floor(255 * powerRatio);
    const g = Math.floor(255 * (1 - powerRatio));
    ctx.strokeStyle = `rgb(${r}, ${g}, 0)`;
    ctx.lineWidth = 5 + (powerRatio * 5);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(arrowEnd.x, arrowEnd.y, 8, 0, Math.PI*2);
    ctx.fillStyle = `rgb(${r}, ${g}, 0)`;
    ctx.fill();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawIsland();
    balls.forEach(b => b.draw());
    if (gameState === 'PLAY' && !window.wasMoving) drawAim();
}

function animate() {
    if (gameState !== 'MENU') {
        update();
        draw();
        requestAnimationFrame(animate);
    }
}

// --- INPUTS ---
function getPos(e) {
    const r = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - r.top;
    return new Vector(x, y);
}

function onDown(e) {
    if (gameState !== 'PLAY' || window.wasMoving) return;
    const pos = getPos(e);
    
    for (let b of balls) {
        if (!b.isDead && b.player === turn && pos.dist(b.pos) < b.r * 1.5) {
            selectedBall = b;
            isDragging = true;
            dragStart = pos;
            dragCurrent = pos;
            // Play click sound?
            break;
        }
    }
}

function onMove(e) {
    if (!isDragging) return;
    e.preventDefault();
    dragCurrent = getPos(e);
}

function onUp(e) {
    if (!isDragging) return;
    
    let aim = selectedBall.pos.sub(dragCurrent);
    let mag = aim.mag();
    
    if (mag > 10) {
        let power = Math.min(mag * 0.15, MAX_POWER);
        selectedBall.vel = aim.norm().mult(power);
        // Sound handled in collision/logic usually, but we can play a "woosh"
    }
    
    isDragging = false;
    selectedBall = null;
}

canvas.addEventListener('mousedown', onDown);
window.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', onUp);

canvas.addEventListener('touchstart', onDown, {passive:false});
window.addEventListener('touchmove', onMove, {passive:false});
window.addEventListener('touchend', onUp);

resize();
drawIsland();

</script>
</body>
</html>